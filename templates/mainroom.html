<!-- chat/templates/chat/room.html -->
{% load static %}
<!DOCTYPE html>
<html>
<head>
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600,700,300' rel='stylesheet'
        type='text/css'>
    <script src="https://use.typekit.net/hoy3lrg.js"></script>
    <script>try { Typekit.load({ async: true }); } catch (e) { }</script>
    <link rel='stylesheet prefetch' href='https://cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css'>
    <link rel='stylesheet prefetch'
        href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css'>
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" rel="stylesheet" id="bootstrap-css">
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <link href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" rel="stylesheet" id="bootstrap-css">
    <script src="//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
    <script src="//code.jquery.com/jquery-1.11.1.min.js"></script>
    <style>
        body {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    background: #27ae60;
    font-family: "proxima-nova", "Source Sans Pro", sans-serif;
    font-size: 1em;
    letter-spacing: 0.1px;
    color: #32465a;
    text-rendering: optimizeLegibility;
    text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.004);
    -webkit-font-smoothing: antialiased;
}

#frame {
    width: 100%;
    min-width: 360px;
    height: 100vh;
    min-height: 300px;
    background: #E6EAEA;
}

@media screen and (max-width: 360px) {
    #frame {
        width: 100%;
        height: 100vh;
    }
}

#frame #sidepanel {
    float: left;
    min-width: 280px;
    max-width: 340px;
    width: 40%;
    height: 100%;
    background: #2c3e50;
    color: #f5f5f5;
    overflow: hidden;
    position: relative;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel {
        width: 100px;
        min-width: 100px;
    }
}

#frame #sidepanel #profile {
    width: 80%;
    margin: 25px auto;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #profile {
        width: 100%;
        margin: 0 auto;
        padding: 5px 0 0 0;
        background: #32465a;
    }
}

#frame #sidepanel #profile.expanded .wrap {
    height: 210px;
    line-height: initial;
}

#frame #sidepanel #profile.expanded .wrap p {
    margin-top: 20px;
}

#frame #sidepanel #profile.expanded .wrap i.expand-button {
    -moz-transform: scaleY(-1);
    -o-transform: scaleY(-1);
    -webkit-transform: scaleY(-1);
    transform: scaleY(-1);
    filter: FlipH;
    -ms-filter: "FlipH";
}

#frame #sidepanel #profile .wrap {
    height: 65px;
    line-height: 65px;
    overflow: hidden;
    -moz-transition: 0.3s height ease;
    -o-transition: 0.3s height ease;
    -webkit-transition: 0.3s height ease;
    transition: 0.3s height ease;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #profile .wrap {
        height: 65px;
    }
}

#frame #sidepanel #profile .wrap img {
    width: 60px;
    border-radius: 50%;
    padding: 3px;
    border: 2px solid #e74c3c;
    height: auto;
    float: left;
    cursor: pointer;
    -moz-transition: 0.3s border ease;
    -o-transition: 0.3s border ease;
    -webkit-transition: 0.3s border ease;
    transition: 0.3s border ease;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #profile .wrap img {
        width: 60px;
        margin-left: 4px;
    }
}

#frame #sidepanel #profile .wrap img.online {
    border: 2px solid #2ecc71;
}

#frame #sidepanel #profile .wrap img.away {
    border: 2px solid #f1c40f;
}

#frame #sidepanel #profile .wrap img.busy {
    border: 2px solid #e74c3c;
}

#frame #sidepanel #profile .wrap img.offline {
    border: 2px solid #95a5a6;
}

#frame #sidepanel #profile .wrap p {
    float: left;
    margin-left: 15px;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #profile .wrap p {
        display: none;
    }
}

#frame #sidepanel #profile .wrap i.expand-button {
    float: right;
    margin-top: 23px;
    font-size: 0.8em;
    cursor: pointer;
    color: #435f7a;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #profile .wrap i.expand-button {
        display: none;
    }
}

#frame #sidepanel #profile .wrap #status-options {
    position: absolute;
    opacity: 0;
    visibility: hidden;
    width: 150px;
    margin: 70px 0 0 0;
    border-radius: 6px;
    z-index: 99;
    line-height: initial;
    background: #435f7a;
    -moz-transition: 0.3s all ease;
    -o-transition: 0.3s all ease;
    -webkit-transition: 0.3s all ease;
    transition: 0.3s all ease;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #profile .wrap #status-options {
        width: 58px;
        margin-top: 57px;
    }
}

#frame #sidepanel #profile .wrap #status-options.active {
    opacity: 1;
    visibility: visible;
    margin: 75px 0 0 0;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #profile .wrap #status-options.active {
        margin-top: 62px;
    }
}

#frame #sidepanel #profile .wrap #status-options:before {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    border-left: 6px solid transparent;
    border-right: 6px solid transparent;
    border-bottom: 8px solid #435f7a;
    margin: -8px 0 0 24px;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #profile .wrap #status-options:before {
        margin-left: 23px;
    }
}

#frame #sidepanel #profile .wrap #status-options ul {
    overflow: hidden;
    border-radius: 6px;
}

#frame #sidepanel #profile .wrap #status-options ul li {
    padding: 15px 0 30px 18px;
    display: block;
    cursor: pointer;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #profile .wrap #status-options ul li {
        padding: 15px 0 35px 22px;
    }
}

#frame #sidepanel #profile .wrap #status-options ul li:hover {
    background: #496886;
}

#frame #sidepanel #profile .wrap #status-options ul li span.status-circle {
    position: absolute;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin: 5px 0 0 0;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #profile .wrap #status-options ul li span.status-circle {
        width: 14px;
        height: 14px;
    }
}

#frame #sidepanel #profile .wrap #status-options ul li span.status-circle:before {
    content: '';
    position: absolute;
    width: 14px;
    height: 14px;
    margin: -3px 0 0 -3px;
    background: transparent;
    border-radius: 50%;
    z-index: 0;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #profile .wrap #status-options ul li span.status-circle:before {
        height: 18px;
        width: 18px;
    }
}

#frame #sidepanel #profile .wrap #status-options ul li p {
    padding-left: 12px;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #profile .wrap #status-options ul li p {
        display: none;
    }
}

#frame #sidepanel #profile .wrap #status-options ul li#status-online span.status-circle {
    background: #2ecc71;
}

#frame #sidepanel #profile .wrap #status-options ul li#status-online.active span.status-circle:before {
    border: 1px solid #2ecc71;
}

#frame #sidepanel #profile .wrap #status-options ul li#status-away span.status-circle {
    background: #f1c40f;
}

#frame #sidepanel #profile .wrap #status-options ul li#status-away.active span.status-circle:before {
    border: 1px solid #f1c40f;
}

#frame #sidepanel #profile .wrap #status-options ul li#status-busy span.status-circle {
    background: #e74c3c;
}

#frame #sidepanel #profile .wrap #status-options ul li#status-busy.active span.status-circle:before {
    border: 1px solid #e74c3c;
}

#frame #sidepanel #profile .wrap #status-options ul li#status-offline span.status-circle {
    background: #95a5a6;
}

#frame #sidepanel #profile .wrap #status-options ul li#status-offline.active span.status-circle:before {
    border: 1px solid #95a5a6;
}

#frame #sidepanel #profile .wrap #expanded {
    padding: 100px 0 0 0;
    display: block;
    line-height: initial !important;
}

#frame #sidepanel #profile .wrap #expanded label {
    float: left;
    clear: both;
    margin: 0 8px 5px 0;
    padding: 5px 0;
}

#frame #sidepanel #profile .wrap #expanded input {
    border: none;
    margin-bottom: 6px;
    background: #32465a;
    border-radius: 3px;
    color: #f5f5f5;
    padding: 7px;
    width: calc(100% - 43px);
}

#frame #sidepanel #profile .wrap #expanded input:focus {
    outline: none;
    background: #435f7a;
}

#frame #sidepanel #search {
    border-top: 1px solid #32465a;
    border-bottom: 1px solid #32465a;
    font-weight: 300;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #search {
        display: none;
    }
}

#frame #sidepanel #search label {
    position: absolute;
    margin: 10px 0 0 20px;
}

#frame #sidepanel #search input {
    font-family: "proxima-nova", "Source Sans Pro", sans-serif;
    padding: 10px 0 10px 46px;
    width: calc(100% - 25px);
    border: none;
    background: #32465a;
    color: #f5f5f5;
}

#frame #sidepanel #search input:focus {
    outline: none;
    background: #435f7a;
}

#frame #sidepanel #search input::-webkit-input-placeholder {
    color: #f5f5f5;
}

#frame #sidepanel #search input::-moz-placeholder {
    color: #f5f5f5;
}

#frame #sidepanel #search input:-ms-input-placeholder {
    color: #f5f5f5;
}

#frame #sidepanel #search input:-moz-placeholder {
    color: #f5f5f5;
}

#frame #sidepanel #contacts {
    height: calc(100% - 177px);
    overflow-y: scroll;
    overflow-x: hidden;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #contacts {
        height: calc(100% - 149px);
        overflow-y: scroll;
        overflow-x: hidden;
    }

    #frame #sidepanel #contacts::-webkit-scrollbar {
        display: none;
    }
}

#frame #sidepanel #contacts.expanded {
    height: calc(100% - 334px);
}

#frame #sidepanel #contacts::-webkit-scrollbar {
    width: 8px;
    background: #2c3e50;
}

#frame #sidepanel #contacts::-webkit-scrollbar-thumb {
    background-color: #243140;
}

#frame #sidepanel #contacts ul li.contact {
    position: relative;
    padding: 10px 0 15px 0;
    font-size: 0.9em;
    cursor: pointer;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #contacts ul li.contact {
        padding: 6px 0 66px 8px;
    }
}

#frame #sidepanel #contacts ul li.contact:hover {
    background: #32465a;
}

#frame #sidepanel #contacts ul li.contact.active {
    background: #32465a;
    border-right: 5px solid #435f7a;
}

#frame #sidepanel #contacts ul li.contact.active span.contact-status {
    border: 2px solid #32465a !important;
}

#frame #sidepanel #contacts ul li.contact .wrap {
    width: 88%;
    margin: 0 auto;
    position: relative;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #contacts ul li.contact .wrap {
        width: 100%;
    }
}

#frame #sidepanel #contacts ul li.contact .wrap span {
    position: absolute;
    left: 0;
    margin: -2px 0 0 -2px;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    border: 2px solid #2c3e50;
    background: #95a5a6;
}

#frame #sidepanel #contacts ul li.contact .wrap span.online {
    background: #2ecc71;
}

#frame #sidepanel #contacts ul li.contact .wrap span.away {
    background: #f1c40f;
}

#frame #sidepanel #contacts ul li.contact .wrap span.busy {
    background: #e74c3c;
}

#frame #sidepanel #contacts ul li.contact .wrap img {
    width: 50px;
    border-radius: 50%;
    float: left;
    margin-right: 10px;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #contacts ul li.contact .wrap img {
        margin-right: 0px;
    }
}

#frame #sidepanel #contacts ul li.contact .wrap .meta {
    padding: 5px 0 0 0;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #contacts ul li.contact .wrap .meta {
        display: none;
    }
}

#frame #sidepanel #contacts ul li.contact .wrap .meta .name {
    font-weight: 600;
}

#frame #sidepanel #contacts ul li.contact .wrap .meta .preview {
    margin: 5px 0 0 0;
    padding: 0 0 1px;
    font-weight: 400;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    -moz-transition: 1s all ease;
    -o-transition: 1s all ease;
    -webkit-transition: 1s all ease;
    transition: 1s all ease;
}

#frame #sidepanel #contacts ul li.contact .wrap .meta .preview span {
    position: initial;
    border-radius: initial;
    background: none;
    border: none;
    padding: 0 2px 0 0;
    margin: 0 0 0 1px;
    opacity: .5;
}

#frame #sidepanel #bottom-bar {
    position: absolute;
    width: 100%;
    bottom: 0;
}

#frame #sidepanel #bottom-bar button {
    float: left;
    border: none;
    width: 50%;
    padding: 10px 0;
    background: #32465a;
    color: #f5f5f5;
    cursor: pointer;
    font-size: 0.85em;
    font-family: "proxima-nova", "Source Sans Pro", sans-serif;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #bottom-bar button {
        float: none;
        width: 100%;
        padding: 15px 0;
    }
}

#frame #sidepanel #bottom-bar button:focus {
    outline: none;
}

#frame #sidepanel #bottom-bar button:nth-child(1) {
    border-right: 1px solid #2c3e50;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #bottom-bar button:nth-child(1) {
        border-right: none;
        border-bottom: 1px solid #2c3e50;
    }
}

#frame #sidepanel #bottom-bar button:hover {
    background: #435f7a;
}

#frame #sidepanel #bottom-bar button i {
    margin-right: 3px;
    font-size: 1em;
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #bottom-bar button i {
        font-size: 1.3em;
    }
}

@media screen and (max-width: 735px) {
    #frame #sidepanel #bottom-bar button span {
        display: none;
    }
}

#frame .content {
    float: right;
    width: 60%;
    height: 100%;
    overflow: hidden;
    position: relative;
}

@media screen and (max-width: 735px) {
    #frame .content {
        width: calc(100% - 100px);
        min-width: 300px !important;
    }
}

@media screen and (min-width: 900px) {
    #frame .content {
        width: calc(100% - 340px);
    }
}

#frame .content .contact-profile {
    width: 100%;
    height: 80px;
    line-height: 80px;
    background: #f5f5f5;
}

#frame .content .contact-profile img {
    width: 60px;
    border-radius: 50%;
    float: left;
    margin: 9px 12px 0 9px;
}

#frame .content .contact-profile p {
    float: left;
    font-size: 18px;
}

#frame .content .contact-profile .social-media {
    float: right;
}

#frame .content .contact-profile .social-media i {
    margin-left: 14px;
    cursor: pointer;
}

#frame .content .contact-profile .social-media i:nth-last-child(1) {
    margin-right: 20px;
}

#frame .content .contact-profile .social-media i:hover {
    color: #435f7a;
}

#frame .content .messages {
    height: auto;
    min-height: calc(100% - 93px);
    max-height: calc(100% - 93px);
    overflow-y: scroll;
    overflow-x: hidden;
    width: 100%;
}

@media screen and (max-width: 735px) {
    #frame .content .messages {
        max-height: calc(100% - 105px);
    }
}

#frame .content .messages::-webkit-scrollbar {
    width: 8px;
    background: transparent;
}

#frame .content .messages::-webkit-scrollbar-thumb {
    background-color: rgba(0, 0, 0, 0.3);
}

#frame .content .messages ul li {
    display: inline-block;
    clear: both;
    float: left;
    margin: 15px 15px 5px 15px;
    width: calc(100% - 25px);
    font-size: 0.9em;
}

#frame .content .messages ul li:nth-last-child(1) {
    margin-bottom: 20px;
}

#frame .content .messages ul li.sent img {
    margin: 6px 8px 0 0;
}

#frame .content .messages ul li.sent p {
    background: #435f7a;
    color: #f5f5f5;
}

#frame .content .messages ul li.replies img {
    float: right;
    margin: 6px 0 0 8px;
}

#frame .content .messages ul li.replies p {
    background: #f5f5f5;
    float: right;
}

#frame .content .messages ul li img {
    width: 42px;
    border-radius: 50%;
    float: left;
}

#frame .content .messages ul li p {
    display: inline-block;
    padding: 10px 15px;
    border-radius: 20px;
    max-width: 300px;
    line-height: 130%;
    font-size: 18px;
}

@media screen and (min-width: 735px) {
    #frame .content .messages ul li p {
        max-width: 300px;
    }
}

#frame .content .message-input {
    position: absolute;
    bottom: 0;
    width: 100%;
    z-index: 99;
}

#frame .content .message-input .wrap {
    position: relative;
}

#frame .content .message-input .wrap input {
    font-family: "proxima-nova", "Source Sans Pro", sans-serif;
    float: left;
    border: none;
    width: calc(100% - 90px);
    padding: 11px 32px 10px 8px;
    font-size: 1.8em;
    color: #32465a;
}

@media screen and (max-width: 735px) {
    #frame .content .message-input .wrap input {
        padding: 15px 32px 16px 8px;
    }
}

#frame .content .message-input .wrap input:focus {
    outline: none;
}

#frame .content .message-input .wrap .attachment {
    position: absolute;
    right: 60px;
    z-index: 4;
    margin-top: 10px;
    font-size: 1.8em;
    color: #435f7a;
    opacity: .5;
    cursor: pointer;
}

@media screen and (max-width: 735px) {
    #frame .content .message-input .wrap .attachment {
        margin-top: 19px;
        right: 65px;
    }
}

#frame .content .message-input .wrap .attachment:hover {
    opacity: 1;
}

#frame .content .message-input .wrap button {
    float: right;
    border: none;
    width: 50px;
    padding: 12px 0;
    cursor: pointer;
    background: #32465a;
    color: #f5f5f5;
}

@media screen and (max-width: 735px) {
    #frame .content .message-input .wrap button {
        padding: 21px 0;
    }
}

#frame .content .message-input .wrap button:hover {
    background: #435f7a;
}

#frame .content .message-input .wrap button:focus {
    outline: none;
}

.fa {
    font-size: 1.5em !important;
}
    </style>
</head>
<body> 
    <div id="frame">
        <div id="sidepanel">
            <div id="profile">
                <div class="wrap">
                    <img id="profile-img" src="http://emilcarlsson.se/assets/mikeross.png" class="online" alt="" />
                    <p style="font-size: 20px;">{{request.user.username}}</p>
                    <i class="fa fa-chevron-down expand-button" aria-hidden="true"></i>
                    <div id="status-options">
                        <ul>
                            <li id="status-online" class="active"><span class="status-circle"></span>
                                <p>Online</p>
                            </li>
                            <li id="status-away"><span class="status-circle"></span>
                                <p>Away</p>
                            </li>
                            <li id="status-busy"><span class="status-circle"></span>
                                <p>Busy</p>
                            </li>
                            <li id="status-offline"><span class="status-circle"></span>
                                <p>Offline</p>
                            </li>
                        </ul>
                    </div>
                    <div id="expanded">
                        <label for="twitter"><i class="fa fa-facebook fa-fw" aria-hidden="true"></i></label>
                        <input name="twitter" type="text" value="mikeross" />
                        <label for="twitter"><i class="fa fa-twitter fa-fw" aria-hidden="true"></i></label>
                        <input name="twitter" type="text" value="ross81" />
                        <label for="twitter"><i class="fa fa-instagram fa-fw" aria-hidden="true"></i></label>
                        <input name="twitter" type="text" value="mike.ross" />
                    </div>
                </div>
            </div>
<div id="search" style="color: white;">
    <label for="">
        <i class="fa fa-search" aria-hidden="true" style="color: white;"></i>
    </label>
    <input type="text" name="search" placeholder="Search contacts..."
        style="color: white; font-size: 16px; border: none; background-color: transparent;" />
</div>


            <div id="contacts">
                <ul>
                    {% for chat in user_chats %}
<li class="contact">
    <a style="color: white; text-decoration: none; font-size: 14px;" href="{% url 'room' chat.id %}">
        <div class="wrap">
            <span class="contact-status online"></span>
            <img src="http://emilcarlsson.se/assets/louislitt.png" alt="" />
            <div class="meta">
                <p class="name" style="font-size: 16px;">Chat Room #{{forloop.counter}}</p>
                {% if chat.messages.last.contact.user.username == request.user.username %}
                <p class="preview" style="font-size: 14px;">You: {{chat.messages.last.content}}</p>
                {% else %}
                <p class="preview" style="font-size: 14px;">{{chat.messages.last.content}}</p>
                {% endif %}
            </div>
        </div>
    </a>
</li>


                    {% endfor %}
                </ul>
            </div>
            <div id="bottom-bar">
                
                    <button style="height: 100%;width:100%" id="settings"><a
                    style="height: 100%;width: 100%;color: white;font-size: 14px;"
                    href="{% url 'logout' %}"><span>Logout</span></a></button>
                            
            </div>
        </div>
            <div class="content">
                <div class="contact-profile">
                    <img src="http://emilcarlsson.se/assets/louislitt.png" alt="" />
                    <p>{{ other_username }}</p>
                    <div class="social-media">
                        <i class="fa fa-facebook" aria-hidden="true"></i>
                        <i class="fa fa-twitter" aria-hidden="true"></i>
                        <i class="fa fa-instagram" aria-hidden="true"></i>
                    </div>
                </div>
                <div class="messages">
                    <ul id="chat-log">
                        {% comment %} <li class="sent">
                            <img src="http://emilcarlsson.se/assets/mikeross.png" alt="" />
                            <p>How the hell am I supposed to get a jury to believe you when I am not even sure that I do?!</p>
                        </li>
                        <li class="replies">
                            <img src="http://emilcarlsson.se/assets/harveyspecter.png" alt="" />
                            <p>When you're backed against the wall, break the god damn thing down.</p>
                        </li> {% endcomment %}
                    </ul>
                </div>
                <div class="message-input">
                    <div class="wrap">
                        <input id="chat-message-input" type="text" placeholder="Write your message..." />
                        <i class="fa fa-paperclip attachment" aria-hidden="true"></i>
                        <button id="chat-message-submit" class="submit">
                            <i class="fa fa-paper-plane" aria-hidden="true"></i>
                        </button>
                    </div>
                </div>
            </div>
    </div>
        
        <script>
            $(".messages").animate({ scrollTop: $(document).height() }, "fast");

                $("#profile-img").click(function () {
                    $("#status-options").toggleClass("active");
                });

                $(".expand-button").click(function () {
                    $("#profile").toggleClass("expanded");
                    $("#contacts").toggleClass("expanded");
                });

                $("#status-options ul li").click(function () {
                    $("#profile-img").removeClass();
                    $("#status-online").removeClass("active");
                    $("#status-away").removeClass("active");
                    $("#status-busy").removeClass("active");
                    $("#status-offline").removeClass("active");
                    $(this).addClass("active");

                    if ($("#status-online").hasClass("active")) {
                        $("#profile-img").addClass("online");
                    } else if ($("#status-away").hasClass("active")) {
                        $("#profile-img").addClass("away");
                    } else if ($("#status-busy").hasClass("active")) {
                        $("#profile-img").addClass("busy");
                    } else if ($("#status-offline").hasClass("active")) {
                        $("#profile-img").addClass("offline");
                    } else {
                        $("#profile-img").removeClass();
                    };

                    $("#status-options").removeClass("active");
                });

                (function (global, factory) {
                    if (typeof define === 'function' && define.amd) {
                        define([], factory);
                    } else if (typeof module !== 'undefined' && module.exports) {
                        module.exports = factory();
                    } else {
                        global.ReconnectingWebSocket = factory();
                    }
                })(this, function () {

                    if (!('WebSocket' in window)) {
                        return;
                    }

                    function ReconnectingWebSocket(url, protocols, options) {

                        // Default settings
                        var settings = {

                            /** Whether this instance should log debug messages. */
                            debug: false,

                            /** Whether or not the websocket should attempt to connect immediately upon instantiation. */
                            automaticOpen: true,

                            /** The number of milliseconds to delay before attempting to reconnect. */
                            reconnectInterval: 1000,
                            /** The maximum number of milliseconds to delay a reconnection attempt. */
                            maxReconnectInterval: 30000,
                            /** The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. */
                            reconnectDecay: 1.5,

                            /** The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. */
                            timeoutInterval: 2000,

                            /** The maximum number of reconnection attempts to make. Unlimited if null. */
                            maxReconnectAttempts: null,

                            /** The binary type, possible values 'blob' or 'arraybuffer', default 'blob'. */
                            binaryType: 'blob'
                        }
                        if (!options) { options = {}; }

                        // Overwrite and define settings with options if they exist.
                        for (var key in settings) {
                            if (typeof options[key] !== 'undefined') {
                                this[key] = options[key];
                            } else {
                                this[key] = settings[key];
                            }
                        }

                        // These should be treated as read-only properties

                        /** The URL as resolved by the constructor. This is always an absolute URL. Read only. */
                        this.url = url;

                        /** The number of attempted reconnects since starting, or the last successful connection. Read only. */
                        this.reconnectAttempts = 0;

                        /**
                         * The current state of the connection.
                         * Can be one of: WebSocket.CONNECTING, WebSocket.OPEN, WebSocket.CLOSING, WebSocket.CLOSED
                         * Read only.
                         */
                        this.readyState = WebSocket.CONNECTING;

                        /**
                         * A string indicating the name of the sub-protocol the server selected; this will be one of
                         * the strings specified in the protocols parameter when creating the WebSocket object.
                         * Read only.
                         */
                        this.protocol = null;

                        // Private state variables

                        var self = this;
                        var ws;
                        var forcedClose = false;
                        var timedOut = false;
                        var eventTarget = document.createElement('div');

                        // Wire up "on*" properties as event handlers

                        eventTarget.addEventListener('open', function (event) { self.onopen(event); });
                        eventTarget.addEventListener('close', function (event) { self.onclose(event); });
                        eventTarget.addEventListener('connecting', function (event) { self.onconnecting(event); });
                        eventTarget.addEventListener('message', function (event) { self.onmessage(event); });
                        eventTarget.addEventListener('error', function (event) { self.onerror(event); });

                        // Expose the API required by EventTarget

                        this.addEventListener = eventTarget.addEventListener.bind(eventTarget);
                        this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);
                        this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);

                        /**
                         * This function generates an event that is compatible with standard
                         * compliant browsers and IE9 - IE11
                         *
                         * This will prevent the error:
                         * Object doesn't support this action
                         *
                         * http://stackoverflow.com/questions/19345392/why-arent-my-parameters-getting-passed-through-to-a-dispatched-event/19345563#19345563
                         * @param s String The name that the event should use
                         * @param args Object an optional object that the event will use
                         */
                        function generateEvent(s, args) {
                            var evt = document.createEvent("CustomEvent");
                            evt.initCustomEvent(s, false, false, args);
                            return evt;
                        };

                        this.open = function (reconnectAttempt) {
                            ws = new WebSocket(self.url, protocols || []);
                            ws.binaryType = this.binaryType;

                            if (reconnectAttempt) {
                                if (this.maxReconnectAttempts && this.reconnectAttempts > this.maxReconnectAttempts) {
                                    return;
                                }
                            } else {
                                eventTarget.dispatchEvent(generateEvent('connecting'));
                                this.reconnectAttempts = 0;
                            }

                            if (self.debug || ReconnectingWebSocket.debugAll) {
                                console.debug('ReconnectingWebSocket', 'attempt-connect', self.url);
                            }

                            var localWs = ws;
                            var timeout = setTimeout(function () {
                                if (self.debug || ReconnectingWebSocket.debugAll) {
                                    console.debug('ReconnectingWebSocket', 'connection-timeout', self.url);
                                }
                                timedOut = true;
                                localWs.close();
                                timedOut = false;
                            }, self.timeoutInterval);

                            ws.onopen = function (event) {
                                clearTimeout(timeout);
                                if (self.debug || ReconnectingWebSocket.debugAll) {
                                    console.debug('ReconnectingWebSocket', 'onopen', self.url);
                                }
                                self.protocol = ws.protocol;
                                self.readyState = WebSocket.OPEN;
                                self.reconnectAttempts = 0;
                                var e = generateEvent('open');
                                e.isReconnect = reconnectAttempt;
                                reconnectAttempt = false;
                                eventTarget.dispatchEvent(e);
                            };

                            ws.onclose = function (event) {
                                clearTimeout(timeout);
                                ws = null;
                                if (forcedClose) {
                                    self.readyState = WebSocket.CLOSED;
                                    eventTarget.dispatchEvent(generateEvent('close'));
                                } else {
                                    self.readyState = WebSocket.CONNECTING;
                                    var e = generateEvent('connecting');
                                    e.code = event.code;
                                    e.reason = event.reason;
                                    e.wasClean = event.wasClean;
                                    eventTarget.dispatchEvent(e);
                                    if (!reconnectAttempt && !timedOut) {
                                        if (self.debug || ReconnectingWebSocket.debugAll) {
                                            console.debug('ReconnectingWebSocket', 'onclose', self.url);
                                        }
                                        eventTarget.dispatchEvent(generateEvent('close'));
                                    }

                                    var timeout = self.reconnectInterval * Math.pow(self.reconnectDecay, self.reconnectAttempts);
                                    setTimeout(function () {
                                        self.reconnectAttempts++;
                                        self.open(true);
                                    }, timeout > self.maxReconnectInterval ? self.maxReconnectInterval : timeout);
                                }
                            };
                            ws.onmessage = function (event) {
                                if (self.debug || ReconnectingWebSocket.debugAll) {
                                    console.debug('ReconnectingWebSocket', 'onmessage', self.url, event.data);
                                }
                                var e = generateEvent('message');
                                e.data = event.data;
                                eventTarget.dispatchEvent(e);
                            };
                            ws.onerror = function (event) {
                                if (self.debug || ReconnectingWebSocket.debugAll) {
                                    console.debug('ReconnectingWebSocket', 'onerror', self.url, event);
                                }
                                eventTarget.dispatchEvent(generateEvent('error'));
                            };
                        }

                        // Whether or not to create a websocket upon instantiation
                        if (this.automaticOpen == true) {
                            this.open(false);
                        }

                        /**
                         * Transmits data to the server over the WebSocket connection.
                         *
                         * @param data a text string, ArrayBuffer or Blob to send to the server.
                         */
                        this.send = function (data) {
                            if (ws) {
                                if (self.debug || ReconnectingWebSocket.debugAll) {
                                    console.debug('ReconnectingWebSocket', 'send', self.url, data);
                                }
                                return ws.send(data);
                            } else {
                                throw 'INVALID_STATE_ERR : Pausing to reconnect websocket';
                            }
                        };

                        /**
                         * Closes the WebSocket connection or connection attempt, if any.
                         * If the connection is already CLOSED, this method does nothing.
                         */
                        this.close = function (code, reason) {
                            // Default CLOSE_NORMAL code
                            if (typeof code == 'undefined') {
                                code = 1000;
                            }
                            forcedClose = true;
                            if (ws) {
                                ws.close(code, reason);
                            }
                        };

                        /**
                         * Additional public API method to refresh the connection if still open (close, re-open).
                         * For example, if the app suspects bad data / missed heart beats, it can try to refresh.
                         */
                        this.refresh = function () {
                            if (ws) {
                                ws.close();
                            }
                        };
                    }

                    /**
                     * An event listener to be called when the WebSocket connection's readyState changes to OPEN;
                     * this indicates that the connection is ready to send and receive data.
                     */
                    ReconnectingWebSocket.prototype.onopen = function (event) { };
                    /** An event listener to be called when the WebSocket connection's readyState changes to CLOSED. */
                    ReconnectingWebSocket.prototype.onclose = function (event) { };
                    /** An event listener to be called when a connection begins being attempted. */
                    ReconnectingWebSocket.prototype.onconnecting = function (event) { };
                    /** An event listener to be called when a message is received from the server. */
                    ReconnectingWebSocket.prototype.onmessage = function (event) { };
                    /** An event listener to be called when an error occurs. */
                    ReconnectingWebSocket.prototype.onerror = function (event) { };

                    /**
                     * Whether all instances of ReconnectingWebSocket should log debug messages.
                     * Setting this to true is the equivalent of setting all instances of ReconnectingWebSocket.debug to true.
                     */
                    ReconnectingWebSocket.debugAll = false;

                    ReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;
                    ReconnectingWebSocket.OPEN = WebSocket.OPEN;
                    ReconnectingWebSocket.CLOSING = WebSocket.CLOSING;
                    ReconnectingWebSocket.CLOSED = WebSocket.CLOSED;

                    return ReconnectingWebSocket;
                });
        </script>
        <script>
            // MIT License:
                //
                // Copyright (c) 2010-2012, Joe Walnes
                //
                // Permission is hereby granted, free of charge, to any person obtaining a copy
                // of this software and associated documentation files (the "Software"), to deal
                // in the Software without restriction, including without limitation the rights
                // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                // copies of the Software, and to permit persons to whom the Software is
                // furnished to do so, subject to the following conditions:
                //
                // The above copyright notice and this permission notice shall be included in
                // all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
                // THE SOFTWARE.

                /**
                 * This behaves like a WebSocket in every way, except if it fails to connect,
                 * or it gets disconnected, it will repeatedly poll until it successfully connects
                 * again.
                 *
                 * It is API compatible, so when you have:
                 *   ws = new WebSocket('ws://....');
                 * you can replace with:
                 *   ws = new ReconnectingWebSocket('ws://....');
                 *
                 * The event stream will typically look like:
                 *  onconnecting
                 *  onopen
                 *  onmessage
                 *  onmessage
                 *  onclose // lost connection
                 *  onconnecting
                 *  onopen  // sometime later...
                 *  onmessage
                 *  onmessage
                 *  etc...
                 *
                 * It is API compatible with the standard WebSocket API, apart from the following members:
                 *
                 * - `bufferedAmount`
                 * - `extensions`
                 * - `binaryType`
                 *
                 * Latest version: https://github.com/joewalnes/reconnecting-websocket/
                 * - Joe Walnes
                 *
                 * Syntax
                 * ======
                 * var socket = new ReconnectingWebSocket(url, protocols, options);
                 *
                 * Parameters
                 * ==========
                 * url - The url you are connecting to.
                 * protocols - Optional string or array of protocols.
                 * options - See below
                 *
                 * Options
                 * =======
                 * Options can either be passed upon instantiation or set after instantiation:
                 *
                 * var socket = new ReconnectingWebSocket(url, null, { debug: true, reconnectInterval: 4000 });
                 *
                 * or
                 *
                 * var socket = new ReconnectingWebSocket(url);
                 * socket.debug = true;
                 * socket.reconnectInterval = 4000;
                 *
                 * debug
                 * - Whether this instance should log debug messages. Accepts true or false. Default: false.
                 *
                 * automaticOpen
                 * - Whether or not the websocket should attempt to connect immediately upon instantiation. The socket can be manually opened or closed at any time using ws.open() and ws.close().
                 *
                 * reconnectInterval
                 * - The number of milliseconds to delay before attempting to reconnect. Accepts integer. Default: 1000.
                 *
                 * maxReconnectInterval
                 * - The maximum number of milliseconds to delay a reconnection attempt. Accepts integer. Default: 30000.
                 *
                 * reconnectDecay
                 * - The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. Accepts integer or float. Default: 1.5.
                 *
                 * timeoutInterval
                 * - The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. Accepts integer. Default: 2000.
                 *
                 */
                (function (global, factory) {
                    if (typeof define === 'function' && define.amd) {
                        define([], factory);
                    } else if (typeof module !== 'undefined' && module.exports) {
                        module.exports = factory();
                    } else {
                        global.ReconnectingWebSocket = factory();
                    }
                })(this, function () {

                    if (!('WebSocket' in window)) {
                        return;
                    }

                    function ReconnectingWebSocket(url, protocols, options) {

                        // Default settings
                        var settings = {

                            /** Whether this instance should log debug messages. */
                            debug: false,

                            /** Whether or not the websocket should attempt to connect immediately upon instantiation. */
                            automaticOpen: true,

                            /** The number of milliseconds to delay before attempting to reconnect. */
                            reconnectInterval: 1000,
                            /** The maximum number of milliseconds to delay a reconnection attempt. */
                            maxReconnectInterval: 30000,
                            /** The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. */
                            reconnectDecay: 1.5,

                            /** The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. */
                            timeoutInterval: 2000,

                            /** The maximum number of reconnection attempts to make. Unlimited if null. */
                            maxReconnectAttempts: null,

                            /** The binary type, possible values 'blob' or 'arraybuffer', default 'blob'. */
                            binaryType: 'blob'
                        }
                        if (!options) { options = {}; }

                        // Overwrite and define settings with options if they exist.
                        for (var key in settings) {
                            if (typeof options[key] !== 'undefined') {
                                this[key] = options[key];
                            } else {
                                this[key] = settings[key];
                            }
                        }

                        // These should be treated as read-only properties

                        /** The URL as resolved by the constructor. This is always an absolute URL. Read only. */
                        this.url = url;

                        /** The number of attempted reconnects since starting, or the last successful connection. Read only. */
                        this.reconnectAttempts = 0;

                        /**
                         * The current state of the connection.
                         * Can be one of: WebSocket.CONNECTING, WebSocket.OPEN, WebSocket.CLOSING, WebSocket.CLOSED
                         * Read only.
                         */
                        this.readyState = WebSocket.CONNECTING;

                        /**
                         * A string indicating the name of the sub-protocol the server selected; this will be one of
                         * the strings specified in the protocols parameter when creating the WebSocket object.
                         * Read only.
                         */
                        this.protocol = null;

                        // Private state variables

                        var self = this;
                        var ws;
                        var forcedClose = false;
                        var timedOut = false;
                        var eventTarget = document.createElement('div');

                        // Wire up "on*" properties as event handlers

                        eventTarget.addEventListener('open', function (event) { self.onopen(event); });
                        eventTarget.addEventListener('close', function (event) { self.onclose(event); });
                        eventTarget.addEventListener('connecting', function (event) { self.onconnecting(event); });
                        eventTarget.addEventListener('message', function (event) { self.onmessage(event); });
                        eventTarget.addEventListener('error', function (event) { self.onerror(event); });

                        // Expose the API required by EventTarget

                        this.addEventListener = eventTarget.addEventListener.bind(eventTarget);
                        this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);
                        this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);

                        /**
                         * This function generates an event that is compatible with standard
                         * compliant browsers and IE9 - IE11
                         *
                         * This will prevent the error:
                         * Object doesn't support this action
                         *
                         * http://stackoverflow.com/questions/19345392/why-arent-my-parameters-getting-passed-through-to-a-dispatched-event/19345563#19345563
                         * @param s String The name that the event should use
                         * @param args Object an optional object that the event will use
                         */
                        function generateEvent(s, args) {
                            var evt = document.createEvent("CustomEvent");
                            evt.initCustomEvent(s, false, false, args);
                            return evt;
                        };

                        this.open = function (reconnectAttempt) {
                            ws = new WebSocket(self.url, protocols || []);
                            ws.binaryType = this.binaryType;

                            if (reconnectAttempt) {
                                if (this.maxReconnectAttempts && this.reconnectAttempts > this.maxReconnectAttempts) {
                                    return;
                                }
                            } else {
                                eventTarget.dispatchEvent(generateEvent('connecting'));
                                this.reconnectAttempts = 0;
                            }

                            if (self.debug || ReconnectingWebSocket.debugAll) {
                                console.debug('ReconnectingWebSocket', 'attempt-connect', self.url);
                            }

                            var localWs = ws;
                            var timeout = setTimeout(function () {
                                if (self.debug || ReconnectingWebSocket.debugAll) {
                                    console.debug('ReconnectingWebSocket', 'connection-timeout', self.url);
                                }
                                timedOut = true;
                                localWs.close();
                                timedOut = false;
                            }, self.timeoutInterval);

                            ws.onopen = function (event) {
                                clearTimeout(timeout);
                                if (self.debug || ReconnectingWebSocket.debugAll) {
                                    console.debug('ReconnectingWebSocket', 'onopen', self.url);
                                }
                                self.protocol = ws.protocol;
                                self.readyState = WebSocket.OPEN;
                                self.reconnectAttempts = 0;
                                var e = generateEvent('open');
                                e.isReconnect = reconnectAttempt;
                                reconnectAttempt = false;
                                eventTarget.dispatchEvent(e);
                            };

                            ws.onclose = function (event) {
                                clearTimeout(timeout);
                                ws = null;
                                if (forcedClose) {
                                    self.readyState = WebSocket.CLOSED;
                                    eventTarget.dispatchEvent(generateEvent('close'));
                                } else {
                                    self.readyState = WebSocket.CONNECTING;
                                    var e = generateEvent('connecting');
                                    e.code = event.code;
                                    e.reason = event.reason;
                                    e.wasClean = event.wasClean;
                                    eventTarget.dispatchEvent(e);
                                    if (!reconnectAttempt && !timedOut) {
                                        if (self.debug || ReconnectingWebSocket.debugAll) {
                                            console.debug('ReconnectingWebSocket', 'onclose', self.url);
                                        }
                                        eventTarget.dispatchEvent(generateEvent('close'));
                                    }

                                    var timeout = self.reconnectInterval * Math.pow(self.reconnectDecay, self.reconnectAttempts);
                                    setTimeout(function () {
                                        self.reconnectAttempts++;
                                        self.open(true);
                                    }, timeout > self.maxReconnectInterval ? self.maxReconnectInterval : timeout);
                                }
                            };
                            ws.onmessage = function (event) {
                                if (self.debug || ReconnectingWebSocket.debugAll) {
                                    console.debug('ReconnectingWebSocket', 'onmessage', self.url, event.data);
                                }
                                var e = generateEvent('message');
                                e.data = event.data;
                                eventTarget.dispatchEvent(e);
                            };
                            ws.onerror = function (event) {
                                if (self.debug || ReconnectingWebSocket.debugAll) {
                                    console.debug('ReconnectingWebSocket', 'onerror', self.url, event);
                                }
                                eventTarget.dispatchEvent(generateEvent('error'));
                            };
                        }

                        // Whether or not to create a websocket upon instantiation
                        if (this.automaticOpen == true) {
                            this.open(false);
                        }

                        /**
                         * Transmits data to the server over the WebSocket connection.
                         *
                         * @param data a text string, ArrayBuffer or Blob to send to the server.
                         */
                        this.send = function (data) {
                            if (ws) {
                                if (self.debug || ReconnectingWebSocket.debugAll) {
                                    console.debug('ReconnectingWebSocket', 'send', self.url, data);
                                }
                                return ws.send(data);
                            } else {
                                throw 'INVALID_STATE_ERR : Pausing to reconnect websocket';
                            }
                        };

                        /**
                         * Closes the WebSocket connection or connection attempt, if any.
                         * If the connection is already CLOSED, this method does nothing.
                         */
                        this.close = function (code, reason) {
                            // Default CLOSE_NORMAL code
                            if (typeof code == 'undefined') {
                                code = 1000;
                            }
                            forcedClose = true;
                            if (ws) {
                                ws.close(code, reason);
                            }
                        };

                        /**
                         * Additional public API method to refresh the connection if still open (close, re-open).
                         * For example, if the app suspects bad data / missed heart beats, it can try to refresh.
                         */
                        this.refresh = function () {
                            if (ws) {
                                ws.close();
                            }
                        };
                    }

                    /**
                     * An event listener to be called when the WebSocket connection's readyState changes to OPEN;
                     * this indicates that the connection is ready to send and receive data.
                     */
                    ReconnectingWebSocket.prototype.onopen = function (event) { };
                    /** An event listener to be called when the WebSocket connection's readyState changes to CLOSED. */
                    ReconnectingWebSocket.prototype.onclose = function (event) { };
                    /** An event listener to be called when a connection begins being attempted. */
                    ReconnectingWebSocket.prototype.onconnecting = function (event) { };
                    /** An event listener to be called when a message is received from the server. */
                    ReconnectingWebSocket.prototype.onmessage = function (event) { };
                    /** An event listener to be called when an error occurs. */
                    ReconnectingWebSocket.prototype.onerror = function (event) { };

                    /**
                     * Whether all instances of ReconnectingWebSocket should log debug messages.
                     * Setting this to true is the equivalent of setting all instances of ReconnectingWebSocket.debug to true.
                     */
                    ReconnectingWebSocket.debugAll = false;

                    ReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;
                    ReconnectingWebSocket.OPEN = WebSocket.OPEN;
                    ReconnectingWebSocket.CLOSING = WebSocket.CLOSING;
                    ReconnectingWebSocket.CLOSED = WebSocket.CLOSED;

                    return ReconnectingWebSocket;
                });
        </script>
<script>
    var lastMessageId = null;
    var roomID = {{ room_id }}; // Assuming you pass the chat ID from the template
    var username = {{ username }};

    var chatSocket = new ReconnectingWebSocket(
        'ws://' + window.location.host +
        '/ws/chat/' + roomID + '/'); // Use roomID instead of roomName

    chatSocket.onopen = function (e) {
        if (lastMessageId === null) {
            fetchMessages();
        }
    }

    chatSocket.onmessage = function (e) {
        var data = JSON.parse(e.data);
        if (data['command'] === 'messages') {
            // Clear the chat log before appending messages to avoid duplicates
            document.querySelector('#chat-log').innerHTML = '';
            for (let i = 0; i < data['messages'].length; i++) {
                createMessage(data['messages'][i]);
            }
        } else if (data['command'] === 'new_message') {
            // Append new messages to the chat log
            createMessage(data['message']);
        }
    };

    chatSocket.onclose = function (e) {
        console.error('Chat socket closed unexpectedly');
    };

    document.querySelector('#chat-message-input').onkeyup = function (e) {
        if (e.keyCode === 13) {  // enter, return
            document.querySelector('#chat-message-submit').click();
        }
    };

    document.querySelector('#chat-message-submit').onclick = function (e) {
        var messageInputDom = document.getElementById('chat-message-input');
        var message = messageInputDom.value;
        chatSocket.send(JSON.stringify({
            'command': 'new_message',
            'message': message,
            'from': username,
            'chat_id': roomID  // Send chat ID in the request
        }));

        messageInputDom.value = '';
    };

    function fetchMessages() {
        // Include the last message ID and chat ID in the request to retrieve messages since that ID
        chatSocket.send(JSON.stringify({
            'command': 'fetch_messages',
            'last_message_id': lastMessageId,
            'chat_id': roomID  // Send chat ID in the request
        }));
    }

                function createMessage(data) {
                    var author = data['author'];
                    var content = data['content'];
                    var timestamp = new Date(data['timestamp']).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false }); // Format timestamp

                    var msgListTag = document.createElement('li');
                    var imgTag = document.createElement('img');
                    var pTag = document.createElement('p');
                    var timeTag = document.createElement('span'); // Create a span for the timestamp

                    pTag.textContent = content;
                    timeTag.textContent = timestamp; // Set the timestamp text content

                    imgTag.src = 'http://emilcarlsson.se/assets/mikeross.png';

                    if (author === username) {
                        msgListTag.className = 'sent';
                    } else {
                        msgListTag.className = 'replies';
                    }

                    msgListTag.appendChild(imgTag);
                    msgListTag.appendChild(pTag);
                    msgListTag.appendChild(timeTag); // Append the timestamp element

                    document.querySelector('#chat-log').appendChild(msgListTag);
                }

</script>

</body>

</html>